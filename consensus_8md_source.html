<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: consensus.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LogoForDocumentation.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rippled
   </div>
   <div id="projectbrief">C++Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">consensus.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Consensus and Validation</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;**This section is a work in progress!!**</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Consensus is the task of reaching agreement within a distributed system in the</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;presence of faulty or even malicious participants.  This document outlines the</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[Ripple Consensus Algorithm](https://ripple.com/files/ripple/consensus/whitepaper.pdf)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;as implemented in [rippled](https://github.com/ripple/rippled), but</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;focuses on its utility as a generic consensus algorithm independent of the</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;detailed mechanics of the Ripple Consensus Ledger. Most notably, the algorithm</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;does not require fully synchronous communication between all nodes in the</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;network, or even a fixed network topology, but instead achieves consensus via</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;collectively trusted subnetworks.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## Distributed Agreement</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;A challenge for distributed systems is reaching agreement on changes in shared</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;state.  For the Ripple network, the shared state is the current ledger--account</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;information, account balances, order books and other financial data.  We will</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;refer to shared distributed state as a /ledger/ throughout the remainder of this</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;document.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;![Ledger Chain](images/consensus/ledger_chain.png &quot;Ledger Chain&quot;)</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;As shown above, new ledgers are made by applying a set of transactions to the</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;prior ledger.  For the Ripple network, transactions include payments,</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;modification of account settings, updates to offers and more.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;In a centralized system, generating the next ledger is trivial since there is a</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;single unique arbiter of which transactions to include and how to apply them to</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;a ledger.  For decentralized systems, participants must resolve disagreements on</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;the set of transactions to include, the order to apply those transactions, and</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;even the resulting ledger after applying the transactions.  This is even more</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;difficult when some participants are faulty or malicious.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;The Ripple network is a decentralized and **trust-full** network.  Anyone is free</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;to join and participants are free to choose a subset of peers that are</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;collectively trusted to not collude in an attempt to defraud the participant.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;Leveraging this network of trust, the Ripple algorithm has two main components.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;* *Consensus* in which network participants agree on the transactions to apply</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  to a prior ledger, based on the positions of their chosen peers.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;* *Validation* in which network participants agree on what ledger was</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  generated, based on the ledgers generated by chosen peers.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;These phases are continually repeated to process transactions submitted to the</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;network, generating successive ledgers and giving rise to the blockchain ledger</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;history depicted below.  In this diagram, time is flowing to the right, but</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;links between ledgers point backward to the parent.  Also note the alternate</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;Ledger 2 that was generated by some participants, but which failed validation</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;and was abandoned.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;![Block Chain](images/consensus/block_chain.png &quot;Block Chain&quot;)</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;The remainder of this section describes the Consensus and Validation algorithms</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;in more detail and is meant as a companion guide to understanding the generic</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;implementation in `rippled`.  The document **does not** discuss correctness,</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;fault-tolerance or liveness properties of the algorithms or the full details of</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;how they integrate within `rippled` to support the Ripple Consensus Ledger.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;## Consensus Overview</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;### Definitions</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;* The *ledger* is the shared distributed state.  Each ledger has a unique ID to</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  distinguish it from all other ledgers.  During consensus, the *previous*,</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  *prior* or *last-closed* ledger is the most recent ledger seen by consensus</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  and is the basis upon which it will build the next ledger.</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;* A *transaction* is an instruction for an atomic change in the ledger state.  A</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  unique ID distinguishes a transaction from other transactions.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;* A *transaction set* is a set of transactions under consideration by consensus.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  The goal of consensus is to reach agreement on this set.  The generic</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  consensus algorithm does not rely on an ordering of transactions within the</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  set, nor does it specify how to apply a transaction set to a ledger to</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  generate a new ledger.  A unique ID distinguishes a set of transactions from</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  all other sets of transactions.</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;* A *node* is one of the distributed actors running the consensus algorithm.  It</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  has a unique ID to distinguish it from all other nodes.</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;* A *peer*  of a node is another node that it has chosen to follow and which it</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  believes will not collude with other chosen peers.  The choice of peers is not</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  symmetric, since participants can decide on their chosen sets independently.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;* A /position/ is the current belief of the next ledger&#39;s transaction set and</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  close time. Position can refer to the node&#39;s own position or the position of a</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  peer.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;* A *proposal* is one of a sequence of positions a node shares during consensus.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  An initial proposal contains the starting position taken by a node before it</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  considers any peer positions.  If a node subsequently updates its position in</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  response to its peers, it will issue an updated proposal.  A proposal is</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  uniquely identified by the ID of the proposing node, the ID of the position</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  taken, the ID of the prior ledger the proposal is for, and the sequence number</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  of the proposal.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;* A *dispute* is a transaction that is either not part of a node&#39;s position or</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  not in a peer&#39;s position. During consensus, the node will add or remove</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  disputed transactions from its position based on that transaction&#39;s support</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  amongst its peers.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;Note that most types have an ID as a lightweight identifier of instances of that</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;type.  Consensus often operates on the IDs directly since the underlying type is</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;potentially expensive to share over the network.  For example, proposal&#39;s only</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;contain the ID of the position of a peer.  Since many peers likely have the same</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;position, this reduces the need to send the full transaction set multiple times.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;Instead, a node can request the transaction set from the network if necessary.</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;### Overview </div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;![Consensus Overview](images/consensus/consensus_overview.png &quot;Consensus Overview&quot;)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;The diagram above is an overview of the consensus process from the perspective</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;of a single participant.  Recall that during a single consensus round, a node is</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;trying to agree with its peers on which transactions to apply to its prior</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;ledger when generating the next ledger.  It also attempts to agree on the</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;[network time when the ledger closed](#effective_close_time).  There are</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;3 main phases to a consensus round:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;* A call to `startRound` places the node in the `Open` phase.  In this phase,</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;the node is waiting for transactions to include in its open ledger.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;* At some point, the node will `Close` the open ledger and transition to the</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;`Establish` phase.  In this phase, the node shares/receives peer proposals on</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;which transactions should be accepted in the closed ledger.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;* At some point, the node determines it has reached consensus with its peers on</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;which transactions to include. It transitions to the `Accept` phase. In this</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;phase, the node works on applying the transactions to the prior ledger to</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;generate a new closed ledger. Once the new ledger is completed, the node shares</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;the validated ledger hash with the network and makes a call to `startRound` to</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;start the cycle again for the next ledger.</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;Throughout, a heartbeat timer calls `timerEntry` at a regular frequency to drive</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;the process forward. Although the `startRound` call occurs at arbitrary times</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;based on when the initial round began and the time it takes to apply</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;transactions, the transitions from `Open` to `Establish` and `Establish` to</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;`Accept` only occur during calls to `timerEntry`.  Similarly, transactions can</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;arrive at arbitrary times, independent of the heartbeat timer. Transactions</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;received after the `Open` to `Close` transition and not part of peer proposals</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;won&#39;t be considered until the next consensus round.  They are represented above</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;by the light green triangles.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;Peer proposals are issued by a node during a `timerEntry` call, but since peers</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;do not synchronize `timerEntry` calls, they are received by other peers at</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;arbitrary times. Peer proposals are only considered if received prior to the</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;`Establish` to `Accept` transition, and only if the peer is working on the same</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;prior ledger. Peer proposals received after consensus is reached will not be</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;meaningful and are represented above by the circle with the X in it.  Only</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;proposals from chosen peers are considered.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;### Effective Close Time ###         {#effective_close_time}</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    </div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;In addition to agreeing on a transaction set, each consensus round tries to</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;agree on the time the ledger closed.  Each node calculates its own close time</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;when it closes the open ledger.  This exact close time is rounded to the nearest</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;multiple of the current *effective close time resolution*.  It is this</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;*effective close time* that nodes seek to agree on. This allows servers to</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;derive a common time for a ledger without the need for perfectly synchronized</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;clocks. As depicted below, the 3 pink arrows represent exact close times from 3</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;consensus nodes that round to the same effective close time given the current</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;resolution. The purple arrow represents a peer whose estimate rounds to a</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;different effective close time given the current resolution.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;![Effective Close Time](images/consensus/EffCloseTime.png &quot;Effective Close Time&quot;)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;The effective close time is part of the node&#39;s position and is shared with peers</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;in its proposals.  Just like the position on the consensus transaction set, a</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;node will update its close time position in response to its peers&#39; effective</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;close time positions.  Peers can agree to disagree on the close time, in which</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;case the effective close time is taken as 1 second past the prior close.</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;The close time resolution is itself dynamic, decreasing (coarser) resolution in</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;subsequent consensus rounds if nodes are unable to reach consensus on an</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;effective close time and increasing (finer) resolution if nodes consistently</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;reach close time consensus.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;### Modes</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;Internally, a node operates under one of the following consensus modes. Either</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;of the first two modes may be chosen when a consensus round starts.</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;* *Proposing* indicates the node is a full-fledged consensus participant.  It</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  takes on positions and sends proposals to its peers.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;* *Observing* indicates the node is a passive consensus participant.  It</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  maintains a position internally, but does not propose that position to its</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  peers. Instead, it receives peer proposals and updates its position</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  to track the majority of its peers.  This may be preferred if the node is only</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  being used to track the state of the network or during a start-up phase while</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  it is still synchronizing with the network.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;The other two modes are set internally during the consensus round when the node</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;believes it is no longer working on the dominant ledger chain based on peer</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;validations. It checks this on every call to `timerEntry`.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;* *Wrong Ledger* indicates the node is not working on the correct prior ledger</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  and does not have it available.  It requests that ledger from the network, but</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  continues to work towards consensus this round while waiting.  If it had been</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  *proposing*, it will send a special &quot;bowout&quot; proposal to its peers to indicate</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  its change in mode for the rest of this round. For the duration of the round,</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  it defers to peer positions for determining the consensus outcome as if it</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  were just *observing*.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;* *Switch Ledger* indicates that the node has acquired the correct prior ledger</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  from the network. Although it now has the correct prior ledger, the fact that</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  it had the wrong one at some point during this round means it is likely behind</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  and should defer to peer positions for determining the consensus outcome.</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;![Consensus Modes](images/consensus/consensus_modes.png &quot;Consensus Modes&quot;)</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;Once either wrong ledger or switch ledger are reached, the node cannot</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;return to proposing or observing until the next consensus round.  However,</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;the node could change its view of the correct prior ledger, so going from</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;switch ledger to wrong ledger and back again is possible.</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;The distinction between the wrong and switched ledger modes arises because a</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;ledger&#39;s unique identifier may be known by a node before the ledger itself. This</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;reflects that fact that the data corresponding to a ledger may be large and take</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;time to share over the network, whereas the smaller ID could be shared in a peer</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;validation much more quickly. Distinguishing the two states allows the node to</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;decide how best to generate the next ledger once it declares consensus.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;### Phases</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;As depicted in the overview diagram, consensus is best viewed as a progression</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;through 3 phases.  There are 4 public methods of the generic consensus algorithm</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;that determine this progression</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;* `startRound` begins a consensus round.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;* `timerEntry` is called at a regular frequency (`LEDGER_MIN_CLOSE`) and is the</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  only call to consensus that can change the  phase from `Open` to `Establish`</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  or `Accept`.</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;* `peerProposal` is called whenever a peer proposal is received and is what</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  allows a node to update its position in a subsequent `timerEntry` call.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;* `gotTxSet` is called when a transaction set is received from the network. This</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  is typically in response to a prior request from the node to acquire the</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  transaction set corresponding to a disagreeing peer&#39;s position.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;The following subsections describe each consensus phase in more detail and what</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;actions are taken in response to these calls.</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;#### Open</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;The `Open` phase is a quiescent period to allow transactions to build up in the</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;node&#39;s open ledger.  The duration is a trade-off between latency and throughput.</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;A shorter window reduces the latency to generating the next ledger, but also</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;reduces transaction throughput due to fewer transactions accepted into the</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;ledger.</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;A call to `startRound` would forcibly begin the next consensus round, skipping</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;completion of the current round.  This is not expected during normal operation.</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;Calls to `peerProposal` or `gotTxSet` simply store the proposal or transaction</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;set for use in the coming `Establish` phase.</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;A call to `timerEntry` first checks that the node is working on the correct</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;prior ledger. If not, it will update the mode and request the correct ledger.</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;Otherwise, the node checks whether to switch to the `Establish` phase and close</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;the ledger.</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;##### Ledger Close</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;Under normal circumstances, the open ledger period ends when one of the following</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;is true</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;* if there are transactions in the open ledger and more than `LEDGER_MIN_CLOSE`</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  have elapsed.  This is the typical behavior.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;* if there are no open transactions and a suitably longer idle interval has</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  elapsed.  This increases the opportunity to get some transaction into</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  the next ledger and avoids doing useless work closing an empty ledger.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;* if more than half the number of prior round peers have already closed or finished</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  this round. This indicates the node is falling behind and needs to catch up.</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;When closing the ledger, the node takes its initial position based on the</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;transactions in the open ledger and uses the current time as</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;its initial close time estimate.  If in the proposing mode, the node shares its</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;initial position with peers.  Now that the node has taken a position, it will</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;consider any peer positions for this round that arrived earlier.  The node</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;generates disputed transactions for each transaction not in common with a peer&#39;s</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;position.  The node also records the vote of each peer for each disputed</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;transaction.</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;In the example below, we suppose our node has closed with transactions 1,2 and 3.  It creates disputes</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;for transactions 2,3 and 4, since at least one peer position differs on each.</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;##### disputes #####     {#disputes_image}</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;![Disputes](images/consensus/disputes.png &quot;Disputes&quot;)</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;#### Establish</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;The establish phase is the active period of consensus in which the node</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;exchanges proposals with peers in an attempt to reach agreement on the consensus</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;transactions and effective close time.</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;A call to `startRound` would forcibly begin the next consensus round, skipping</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;completion of the current round.  This is not expected during normal operation.</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;Calls to `peerProposal` or `gotTxSet` that reflect new positions will generate</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;disputed transactions for any new disagreements and will update the peer&#39;s vote</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;for all disputed transactions.</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;A call to `timerEntry` first checks that the node is working from the correct</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;prior ledger. If not, the node  will update the mode and request the correct</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;ledger.  Otherwise, the node updates the node&#39;s position and considers whether</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;to switch to the `Accepted` phase and declare consensus reached.  However, at</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;least `LEDGER_MIN_CONSENSUS` time must have elapsed before doing either.  This</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;allows peers an opportunity to take an initial position and share it.</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;##### Update Position</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;In order to achieve consensus, the node is looking for a transaction set that is</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;supported by a super-majority of peers.  The node works towards this set by</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;adding or removing disputed transactions from its position based on an</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;increasing threshold for inclusion.</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;![Threshold](images/consensus/threshold.png &quot;Threshold&quot;)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;By starting with a lower threshold, a node initially allows a wide set of</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;transactions into its position. If the establish round continues and the node is</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;&quot;stuck&quot;, a higher threshold can focus on accepting transactions with the most</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;support.  The constants that define the thresholds and durations at which the</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;thresholds change are given by `AV_XXX_CONSENSUS_PCT` and</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;`AV_XXX_CONSENSUS_TIME` respectively, where `XXX` is `INIT`,`MID`,`LATE` and</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;`STUCK`.  The effective close time position is updated using the same</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;thresholds.</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;Given the [example disputes above](#disputes_image) and an initial threshold</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;of 50%, our node would retain its position since transaction 1 was not in</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;dispute and transactions 2 and 3 have 75% support.  Since its position did not</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;change, it would not need to send a new proposal to peers.  Peer C would not</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;change either. Peer A would add transaction 3 to its position and Peer B would</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;remove transaction 4 from its position; both would then send an updated</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;position.</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;Conversely, if the diagram reflected a later call to =timerEntry= that occurs in</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;the stuck region with a threshold of say 95%, our node would remove transactions</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;2 and 3 from its candidate set and send an updated position.  Likewise, all the</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;other peers would end up with only transaction 1 in their position.</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;Lastly, if our node were not in the proposing mode, it would not include its own</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;vote and just take the majority (&gt;50%) position of its peers. In this example,</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;our node would maintain its position of transactions 1, 2 and 3.</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;##### Checking Consensus</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;After updating its position, the node checks for supermajority agreement with</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;its peers on its current position.  This agreement is of the exact transaction</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;set, not just the support of individual transactions. That is, if our position</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;is a subset of a peer&#39;s position, that counts as a disagreement. Also recall</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;that effective close time agreement allows a supermajority of participants</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;agreeing to disagree.</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;Consensus is declared when the following 3 clauses are true:</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;* `LEDGER_MIN_CONSENSUS` time has elapsed in the establish phase</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;* At least 75% of the prior round proposers have proposed OR this establish</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  phase is `LEDGER_MIN_CONSENSUS` longer than the last round&#39;s establish phase</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;* `minimumConsensusPercentage` of ourself and our peers share the same position</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;The middle condition ensures slower peers have a chance to share positions, but</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;prevents waiting too long on peers that have disconnected. Additionally, a node</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;can declare that consensus has moved on if `minimumConsensusPercentage` peers</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;have sent validations and moved on to the next ledger. This outcome indicates</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;the node has fallen behind its peers and needs to catch up.</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;If a node is not proposing, it does not include its own position when</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;calculating the percent of agreeing participants but otherwise follows the above</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;logic.</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;##### Accepting Consensus</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;Once consensus is reached (or moved on), the node switches to the `Accept` phase</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;and signals to the implementing code that the round is complete. That code is</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;responsible for using the consensus transaction set to generate the next ledger</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;and calling `startRound` to begin the next round.  The implementation has total</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;freedom on ordering transactions, deciding what to do if consensus moved on,</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;determining whether to retry or abandon local transactions that did not make the</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;consensus set and updating any internal state based on the consensus progress.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;#### Accept</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;The `Accept` phase is the terminal phase of the consensus algorithm.  Calls to</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;`timerEntry`, `peerProposal` and `gotTxSet` will not change the internal</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;consensus state while in the accept phase.  The expectation is that the</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;application specific code is working to generate the new ledger based on the</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;consensus outcome. Once complete, that code should make a call to `startRound`</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;to kick off the next consensus round. The `startRound` call includes the new</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;prior ledger, prior ledger ID and whether the round should begin in the</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;proposing or observing mode.  After setting some initial state, the phase</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;transitions to `Open`.  The node will also check if the provided prior ledger</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;and ID are correct, updating the mode and requesting the proper ledger from the</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;network if necessary.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;## Consensus Type Requirements</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;The consensus type requirements are given below as minimal implementation stubs.</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;Actual implementations would augment these stubs with members appropriate for</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;managing the details of transactions and ledgers within the larger application</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;framework.</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;### Transaction</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;The transaction type `Tx` encapsulates a single transaction under consideration</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;by consensus.</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;```{.cpp}</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;struct Tx</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;{</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;   using ID = ...;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;   ID const &amp; id() const;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;   //... implementation specific</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;};</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;```</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;### Transaction Set</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;The transaction set type `TxSet` represents a set of `Tx`s that are collectively</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;under consideration by consensus. A `TxSet` can be compared against other `TxSet`s</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;(typically from peers) and can be modified to add or remove transactions via</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;the mutable subtype.</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;```{.cpp}</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;struct TxSet</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;{</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  using Tx = Tx;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  using ID = ...;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  ID const &amp; id() const;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  bool exists(Tx::ID const &amp;) const;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  Tx const * find(Tx::ID const &amp;) const ;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  // Return set of transactions that are not common with another set</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  // Bool in map is true if in our set, false if in other</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  std::map&lt;Tx::ID, bool&gt; compare(TxSet const &amp; other) const;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  // A mutable view that allows changing transactions in the set</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  struct MutableTxSet</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  {</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      MutableTxSet(TxSet const &amp;);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;      bool insert(Tx const &amp;);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;      bool erase(Tx::ID const &amp;);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  };</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  // Construct from a mutable view.</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  TxSet(MutableTxSet const &amp;);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  // Alternatively, if the TxSet is itself mutable</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  // just alias MutableTxSet = TxSet</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  //... implementation specific</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;};</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;```</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;### Ledger</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;The `Ledger` type represents the state shared amongst the</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;distributed participants.  Notice that the details of how the next ledger is</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;generated from the prior ledger and the consensus accepted transaction set is</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;not part of the interface.  Within the generic code, this type is primarily used</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;to know that peers are working on the same tip of the ledger chain and to</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;provide some basic timing data for consensus.</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;```{.cpp}</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;struct Ledger</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;{</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  using ID = ...;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  using Seq = //std::uint32_t?...;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  ID const &amp; id() const;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  // Sequence number that is 1 more than the parent ledger&#39;s seq()</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  Seq seq() const;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  // Whether the ledger&#39;s close time was a non-trivial consensus result</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  bool closeAgree() const;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  // The close time resolution used in determing the close time</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  NetClock::duration closeTimeResolution() const;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  // The (effective) close time, based on the closeTimeResolution</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  NetClock::time_point closeTime() const;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  // The parent ledger&#39;s close time</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;  NetClock::time_point parentCloseTime() const;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  Json::Value getJson() const;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  //... implementation specific</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;};</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;```</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;### PeerProposal</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;The `PeerProposal` type represents the signed position taken</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;by a peer during consensus. The only type requirement is owning an instance of a</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;generic `ConsensusProposal`.</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;```{.cpp}</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;// Represents our proposed position or a peer&#39;s proposed position</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;// and is provided with the generic code</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;template &lt;class NodeID_t, class LedgerID_t, class Position_t&gt; class ConsensusProposal;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;struct PeerPosition</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;{</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  ConsensusProposal&lt;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;      NodeID_t,</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;      typename Ledger::ID,</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      typename TxSet::ID&gt; const &amp;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  proposal() const;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  // ... implementation specific</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;};</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;```</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;### Generic Consensus Interface</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;The generic `Consensus` relies on `Adaptor` template class to implement a set</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;of helper functions that plug the consensus algorithm into a specific application.</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;The `Adaptor` class also defines the types above needed by the algorithm. Below</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;are excerpts of the generic consensus implementation and of helper types that will</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;interact with the concrete implementing class.</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;```{.cpp}</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;// Represents a transction under dispute this round</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;template &lt;class Tx_t, class NodeID_t&gt; class DisputedTx;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;// Represents how the node participates in Consensus this round</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;enum class ConsensusMode { proposing, observing, wrongLedger, switchedLedger};</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;// Measure duration of phases of consensus</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;class ConsensusTimer</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;{</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;public:</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    std::chrono::milliseconds read() const;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    // details omitted ...</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;};</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;// Initial ledger close times, not rounded by closeTimeResolution</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;// Used to gauge degree of synchronization between a node and its peers</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;struct ConsensusCloseTimes</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;{</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    std::map&lt;NetClock::time_point, int&gt; peers;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    NetClock::time_point self;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;};</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;// Encapsulates the result of consensus.</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;template &lt;class Adaptor&gt;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;struct ConsensusResult</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;{</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    //! The set of transactions consensus agrees go in the ledger</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    Adaptor::TxSet_t set;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;    //! Our proposed position on transactions/close time</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    ConsensusProposal&lt;...&gt; position;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    //! Transactions which are under dispute with our peers</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    hash_map&lt;Adaptor::Tx_t::ID, DisputedTx&lt;...&gt;&gt; disputes;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    // Set of TxSet ids we have already compared/created disputes</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    hash_set&lt;typename Adaptor::TxSet_t::ID&gt; compares;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    // Measures the duration of the establish phase for this consensus round</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    ConsensusTimer roundTime;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    // Indicates state in which consensus ended.  Once in the accept phase</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    // will be either Yes or MovedOn</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    ConsensusState state = ConsensusState::No;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;};</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;template &lt;class Adaptor&gt;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;class Consensus</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;{</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;public:</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    Consensus(clock_type, Adaptor &amp;, beast::journal);</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    // Kick-off the next round of consensus.</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    void startRound(</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        NetClock::time_point const&amp; now,</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        typename Ledger_t::ID const&amp; prevLedgerID,</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        Ledger_t const&amp; prevLedger,</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        bool proposing);</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    // Call periodically to drive consensus forward.</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    void timerEntry(NetClock::time_point const&amp; now);</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    // A peer has proposed a new position, adjust our tracking.  Return true if the proposal</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    // was used.</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    bool peerProposal(NetClock::time_point const&amp; now, Proposal_t const&amp; newProposal);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    // Process a transaction set acquired from the network</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    void gotTxSet(NetClock::time_point const&amp; now, TxSet_t const&amp; txSet);</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    // ... details</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;};</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;```</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;### Adapting Generic Consensus</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;The stub below shows the set of callback/helper functions required in the implementing class.</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;```{.cpp}</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;struct Adaptor</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;{</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    using Ledger_t = Ledger;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    using TxSet_t = TxSet;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    using PeerProposal_t = PeerProposal;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    using NodeID_t = ...; // Integer-like std::uint32_t to uniquely identify a node</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    // Attempt to acquire a specific ledger from the network.</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    boost::optional&lt;Ledger&gt; acquireLedger(Ledger::ID const &amp; ledgerID);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    // Acquire the transaction set associated with a proposed position.</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    boost::optional&lt;TxSet&gt; acquireTxSet(TxSet::ID const &amp; setID);</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    // Whether any transactions are in the open ledger</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    bool hasOpenTransactions() const;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    // Number of proposers that have validated the given ledger</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    std::size_t proposersValidated(Ledger::ID const &amp; prevLedger) const;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    // Number of proposers that have validated a ledger descended from the</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    // given ledger</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    std::size_t proposersFinished(Ledger::ID const &amp; prevLedger) const;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    // Return the ID of the last closed (and validated) ledger that the</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    // application thinks consensus should use as the prior ledger.</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    Ledger::ID getPrevLedger(Ledger::ID const &amp; prevLedgerID,</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                    Ledger const &amp; prevLedger,</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                    ConsensusMode mode);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    // Called when consensus operating mode changes</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    void onModeChange(ConsensuMode before, ConsensusMode after);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    </div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    // Called when ledger closes.  Implementation should generate an initial Result</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    // with position based on the current open ledger&#39;s transactions.</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    ConsensusResult onClose(Ledger const &amp;, Ledger const &amp; prev, ConsensusMode mode);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    // Called when ledger is accepted by consensus</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    void onAccept(ConsensusResult const &amp; result,</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      RCLCxLedger const &amp; prevLedger,</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;      NetClock::duration closeResolution,</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;      ConsensusCloseTimes const &amp; rawCloseTimes,</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;      ConsensusMode const &amp; mode);</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    // Propose the position to peers.</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    void propose(ConsensusProposal&lt;...&gt; const &amp; pos);</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    // Share a received peer proposal with other peers.</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    void share(PeerPosition_t const &amp; pos);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    // Share a disputed transaction with peers</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    void share(TxSet::Tx const &amp; tx);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    // Share given transaction set with peers</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    void share(TxSet const &amp;s);</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    //... implementation specific</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;};</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;```</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;The implementing class hides many details of the peer communication</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;model from the generic code.</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;* The `share` member functions are responsible for sharing the given type with a</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  node&#39;s peers, but are agnostic to the mechanism. Ideally, messages are delivered</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  faster than `LEDGER_GRANULARITY`. </div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;* The generic code does not specify how transactions are submitted by clients,</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  propagated through the network or stored in the open ledger. Indeed, the open</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;  ledger is only conceptual from the perspective of the generic code---the</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  initial position and transaction set are opaquely generated in a</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  `Consensus::Result` instance returned from the `onClose` callback.</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;* The calls to `acquireLedger` and `acquireTxSet` only have non-trivial return</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  if the ledger or transaction set of interest is available.  The implementing</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  class is free to block while acquiring, or return the empty option while</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  servicing the request asynchronously.  Due to legacy reasons, the two calls</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;  are not symmetric. `acquireTxSet` requires the host application to call</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  `gotTxSet` when an asynchronous `acquire` completes. Conversely,</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;  `acquireLedger` will be called again later by the consensus code if it still</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  desires the ledger with the hope that the asynchronous acquisition is</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  complete.</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;## Validation</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;Coming Soon!</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
